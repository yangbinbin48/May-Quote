# ChatGPTå¼å¯¹è¯åº”ç”¨å¯¼å‡ºåŠŸèƒ½è®¾è®¡

## åŠŸèƒ½æ¦‚è¿°

æœ¬åº”ç”¨æä¾›å¤šæ ·åŒ–çš„å†…å®¹æ“ä½œå’Œå¯¼å‡ºåŠŸèƒ½ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿï¼š

1. é€šè¿‡å³é”®èœå•å¤åˆ¶å¯¹è¯å†…å®¹
2. å°†å†…å®¹ä¿å­˜åˆ°åº”ç”¨å†…ç½®å‰ªè´´æ¿
3. å¯¼å‡ºå•æ¡æ¶ˆæ¯æˆ–æ•´ä¸ªå¯¹è¯ä¸ºå¤šç§æ ¼å¼ï¼ˆMarkdownã€PDFã€Wordï¼‰
4. æ”¯æŒè‡ªå®šä¹‰å¯¼å‡ºæ¨¡æ¿å’Œæ ·å¼

## å³é”®èœå•è®¾è®¡

### èœå•åŠŸèƒ½å’Œå¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¤åˆ¶æ–‡æœ¬                â”‚
â”‚ ä¿å­˜åˆ°å‰ªè´´æ¿            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¯¼å‡ºä¸º...               â”‚ â”€â”
â”‚                         â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â–ºâ”‚ Markdown      â”‚
                                â”‚ PDF           â”‚
                                â”‚ Wordæ–‡æ¡£      â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®ç°æ–¹å¼

```typescript
// å³é”®èœå•ç»„ä»¶
function ContextMenu({ position, messageId, conversationId, onClose }) {
  // èœå•ä½ç½®çŠ¶æ€
  const [pos, setPos] = useState({ x: position.x, y: position.y });
  
  // å¤„ç†å¤åˆ¶æ–‡æœ¬
  const handleCopy = useCallback(async () => {
    const message = await getMessageById(messageId);
    await navigator.clipboard.writeText(message.content);
    toast({
      title: "å¤åˆ¶æˆåŠŸ",
      status: "success",
      duration: 2000,
    });
    onClose();
  }, [messageId, onClose]);
  
  // å¤„ç†ä¿å­˜åˆ°å‰ªè´´æ¿
  const handleSaveToClipboard = useCallback(async () => {
    const message = await getMessageById(messageId);
    await saveToApplicationClipboard({
      content: message.content,
      source: {
        conversationId,
        messageId
      }
    });
    toast({
      title: "å·²ä¿å­˜åˆ°å‰ªè´´æ¿",
      status: "success",
      duration: 2000,
    });
    onClose();
  }, [messageId, conversationId, onClose]);
  
  // å¤„ç†å¯¼å‡º
  const handleExport = useCallback((format: 'markdown' | 'pdf' | 'word') => {
    exportMessage(messageId, format);
    onClose();
  }, [messageId, onClose]);
  
  // èœå•é¡¹é…ç½®
  const menuItems = [
    { label: 'å¤åˆ¶æ–‡æœ¬', onClick: handleCopy, icon: CopyIcon },
    { label: 'ä¿å­˜åˆ°å‰ªè´´æ¿', onClick: handleSaveToClipboard, icon: SaveIcon },
    { 
      label: 'å¯¼å‡ºä¸º...',
      isSubmenu: true,
      submenuItems: [
        { label: 'Markdown', onClick: () => handleExport('markdown'), icon: MarkdownIcon },
        { label: 'PDF', onClick: () => handleExport('pdf'), icon: PDFIcon },
        { label: 'Wordæ–‡æ¡£', onClick: () => handleExport('word'), icon: WordIcon },
      ]
    }
  ];
  
  // è¿”å›èœå•UI
  return (
    <Portal>
      <Box
        position="fixed"
        top={pos.y}
        left={pos.x}
        zIndex={1000}
        bg="white"
        boxShadow="md"
        borderRadius="md"
        overflow="hidden"
        onMouseDown={(e) => e.stopPropagation()}
      >
        {/* èœå•é¡¹æ¸²æŸ“... */}
      </Box>
    </Portal>
  );
}
```

### æ¿€æ´»æ–¹å¼

ä½¿ç”¨Reactçš„onContextMenuäº‹ä»¶å¤„ç†ï¼š

```typescript
function MessageItem({ message }) {
  const [contextMenu, setContextMenu] = useState(null);
  
  const handleContextMenu = useCallback((event) => {
    event.preventDefault();
    setContextMenu({
      position: { x: event.clientX, y: event.clientY },
      messageId: message.id,
      conversationId: message.conversationId
    });
  }, [message]);
  
  return (
    <>
      <Box
        onContextMenu={handleContextMenu}
        // å…¶ä»–å±æ€§...
      >
        {message.content}
      </Box>
      
      {contextMenu && (
        <ContextMenu
          {...contextMenu}
          onClose={() => setContextMenu(null)}
        />
      )}
    </>
  );
}
```

## å‰ªè´´æ¿åŠŸèƒ½å®ç°

### æ•°æ®æ¨¡å‹

```typescript
interface ClipboardItem {
  id: string;        // å”¯ä¸€æ ‡è¯†
  content: string;   // å†…å®¹
  createdAt: number; // åˆ›å»ºæ—¶é—´æˆ³
  source: {          // æ¥æºä¿¡æ¯
    conversationId: string;
    messageId: string;
  };
  tags?: string[];   // å¯é€‰æ ‡ç­¾
}
```

### å­˜å‚¨å®ç°

ä½¿ç”¨IndexedDBå­˜å‚¨å‰ªè´´æ¿å†…å®¹ï¼š

```typescript
import { openDB } from 'idb';

// åˆå§‹åŒ–æ•°æ®åº“
async function initClipboardDB() {
  return openDB('ChatAppDB', 1, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('clipboard')) {
        const store = db.createObjectStore('clipboard', { keyPath: 'id' });
        store.createIndex('createdAt', 'createdAt');
      }
    }
  });
}

// ä¿å­˜åˆ°åº”ç”¨å‰ªè´´æ¿
async function saveToApplicationClipboard(item: Omit<ClipboardItem, 'id' | 'createdAt'>) {
  const db = await initClipboardDB();
  const id = `clip-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  
  await db.add('clipboard', {
    id,
    ...item,
    createdAt: Date.now()
  });
  
  return id;
}

// è·å–å‰ªè´´æ¿å†…å®¹
async function getClipboardItems(limit = 50): Promise<ClipboardItem[]> {
  const db = await initClipboardDB();
  return db.getAllFromIndex('clipboard', 'createdAt')
    .then(items => items
      .sort((a, b) => b.createdAt - a.createdAt)
      .slice(0, limit)
    );
}

// åˆ é™¤å‰ªè´´æ¿é¡¹
async function deleteClipboardItem(id: string): Promise<void> {
  const db = await initClipboardDB();
  return db.delete('clipboard', id);
}

// æ¸…ç©ºå‰ªè´´æ¿
async function clearClipboard(): Promise<void> {
  const db = await initClipboardDB();
  return db.clear('clipboard');
}
```

### å‰ªè´´æ¿UIç»„ä»¶

```typescript
function ClipboardPanel({ isOpen, onClose }) {
  const [items, setItems] = useState<ClipboardItem[]>([]);
  const [loading, setLoading] = useState(true);
  
  // åŠ è½½å‰ªè´´æ¿å†…å®¹
  useEffect(() => {
    if (isOpen) {
      setLoading(true);
      getClipboardItems()
        .then(fetchedItems => setItems(fetchedItems))
        .finally(() => setLoading(false));
    }
  }, [isOpen]);
  
  // å¤åˆ¶åˆ°ç³»ç»Ÿå‰ªè´´æ¿
  const handleCopy = useCallback(async (content: string) => {
    await navigator.clipboard.writeText(content);
    toast({ title: "å·²å¤åˆ¶åˆ°å‰ªè´´æ¿", status: "success" });
  }, []);
  
  // åˆ é™¤é¡¹ç›®
  const handleDelete = useCallback(async (id: string) => {
    await deleteClipboardItem(id);
    setItems(prev => prev.filter(item => item.id !== id));
    toast({ title: "å·²åˆ é™¤", status: "info" });
  }, []);
  
  // å¯¼å‡ºé¡¹ç›®
  const handleExport = useCallback((item: ClipboardItem, format: string) => {
    // æ ¹æ®æ ¼å¼è°ƒç”¨ä¸åŒçš„å¯¼å‡ºå‡½æ•°
    switch (format) {
      case 'markdown':
        exportToMarkdown(item.content, `clip-${item.id}.md`);
        break;
      case 'pdf':
        exportToPDF(item.content, `clip-${item.id}.pdf`);
        break;
      case 'word':
        exportToWord(item.content, `clip-${item.id}.docx`);
        break;
    }
  }, []);
  
  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>åº”ç”¨å‰ªè´´æ¿</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          {loading ? (
            <Center py={10}>
              <Spinner />
            </Center>
          ) : items.length === 0 ? (
            <Center py={10}>
              <Text color="gray.500">å‰ªè´´æ¿ä¸ºç©º</Text>
            </Center>
          ) : (
            <VStack spacing={3} align="stretch">
              {items.map(item => (
                <Box 
                  key={item.id} 
                  p={3} 
                  borderWidth="1px" 
                  borderRadius="md"
                  position="relative"
                >
                  <Text noOfLines={3}>{item.content}</Text>
                  <HStack spacing={2} mt={2}>
                    <IconButton
                      aria-label="å¤åˆ¶"
                      icon={<CopyIcon />}
                      size="sm"
                      onClick={() => handleCopy(item.content)}
                    />
                    <Menu>
                      <MenuButton
                        as={IconButton}
                        aria-label="å¯¼å‡º"
                        icon={<ExportIcon />}
                        size="sm"
                      />
                      <MenuList>
                        <MenuItem onClick={() => handleExport(item, 'markdown')}>
                          Markdown
                        </MenuItem>
                        <MenuItem onClick={() => handleExport(item, 'pdf')}>
                          PDF
                        </MenuItem>
                        <MenuItem onClick={() => handleExport(item, 'word')}>
                          Wordæ–‡æ¡£
                        </MenuItem>
                      </MenuList>
                    </Menu>
                    <IconButton
                      aria-label="åˆ é™¤"
                      icon={<DeleteIcon />}
                      size="sm"
                      colorScheme="red"
                      variant="ghost"
                      onClick={() => handleDelete(item.id)}
                    />
                  </HStack>
                  <Text
                    position="absolute"
                    top={2}
                    right={2}
                    fontSize="xs"
                    color="gray.500"
                  >
                    {new Date(item.createdAt).toLocaleString()}
                  </Text>
                </Box>
              ))}
            </VStack>
          )}
        </ModalBody>
        <ModalFooter>
          <Button variant="ghost" onClick={onClose}>å…³é—­</Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}
```

## æ ¼å¼å¯¼å‡ºåŠŸèƒ½

### Markdownå¯¼å‡ºå®ç°

```typescript
// å¯¼å‡ºæ¶ˆæ¯ä¸ºMarkdown
async function exportToMarkdown(messageId: string, fileName?: string) {
  // è·å–æ¶ˆæ¯
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // åˆ›å»ºmarkdownå†…å®¹
  const markdown = `# ${message.role === 'user' ? 'ç”¨æˆ·' : 'AI'} æ¶ˆæ¯ - ${new Date(message.timestamp).toLocaleString()}
  
${message.content}
  `;
  
  // åˆ›å»ºä¸‹è½½é“¾æ¥
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName || `message-${messageId}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// å¯¼å‡ºæ•´ä¸ªå¯¹è¯ä¸ºMarkdown
async function exportConversationToMarkdown(conversationId: string) {
  // è·å–å¯¹è¯ä¿¡æ¯
  const conversation = await getConversationById(conversationId);
  if (!conversation) return;
  
  // è·å–æ‰€æœ‰æ¶ˆæ¯
  const messages = await getMessagesByConversationId(conversationId);
  if (!messages || messages.length === 0) return;
  
  // åˆ›å»ºmarkdownå†…å®¹
  let markdown = `# å¯¹è¯ï¼š${conversation.title || 'æœªå‘½åå¯¹è¯'}
åˆ›å»ºæ—¶é—´ï¼š${new Date(conversation.createdAt).toLocaleString()}
å¯¼å‡ºæ—¶é—´ï¼š${new Date().toLocaleString()}

`;
  
  // æ·»åŠ æ‰€æœ‰æ¶ˆæ¯
  for (const message of messages) {
    const role = message.role === 'user' ? 'ğŸ‘¤ ç”¨æˆ·' : 
                (message.role === 'assistant' ? 'ğŸ¤– AI' : 'ğŸ”§ ç³»ç»Ÿ');
    markdown += `## ${role} - ${new Date(message.timestamp).toLocaleString()}\n\n${message.content}\n\n---\n\n`;
  }
  
  // åˆ›å»ºä¸‹è½½é“¾æ¥
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `conversation-${conversationId}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
```

### PDFå¯¼å‡ºå®ç°

ä½¿ç”¨html2pdf.jsåº“ï¼š

```typescript
import html2pdf from 'html2pdf.js';

// å¯¼å‡ºæ¶ˆæ¯ä¸ºPDF
async function exportToPDF(messageId: string, fileName?: string) {
  // è·å–æ¶ˆæ¯
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // åˆ›å»ºä¸´æ—¶HTMLå…ƒç´ 
  const container = document.createElement('div');
  container.style.padding = '20px';
  container.style.maxWidth = '800px';
  container.style.margin = '0 auto';
  
  // æ·»åŠ å†…å®¹
  container.innerHTML = `
    <h1 style="color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px;">
      ${message.role === 'user' ? 'ç”¨æˆ·' : 'AI'} æ¶ˆæ¯
    </h1>
    <p style="color: #7f8c8d; font-size: 14px;">
      ${new Date(message.timestamp).toLocaleString()}
    </p>
    <div style="margin-top: 20px; line-height: 1.6; white-space: pre-wrap;">
      ${formatMessageContent(message.content)}
    </div>
  `;
  
  // é…ç½®PDFé€‰é¡¹
  const options = {
    margin: [15, 15],
    filename: fileName || `message-${messageId}.pdf`,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
  };
  
  // ç”ŸæˆPDF
  html2pdf().from(container).set(options).save();
}

// æ ¼å¼åŒ–æ¶ˆæ¯å†…å®¹ï¼Œå°†markdownæ¸²æŸ“ä¸ºHTML
function formatMessageContent(content: string) {
  // è¿™é‡Œå¯ä»¥ä½¿ç”¨markedåº“å°†markdownè½¬ä¸ºHTML
  // æˆ–è€…ä½¿ç”¨å…¶ä»–æ ¼å¼åŒ–é€»è¾‘
  return content
    .replace(/\n/g, '<br>')
    .replace(/```(\w*)([\s\S]*?)```/g, (_, lang, code) => 
      `<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px;"><code>${code}</code></pre>`
    );
}

// å¯¼å‡ºæ•´ä¸ªå¯¹è¯ä¸ºPDF
async function exportConversationToPDF(conversationId: string) {
  // é€»è¾‘ç±»ä¼¼ï¼Œä½†éœ€è¦è·å–å®Œæ•´å¯¹è¯å¹¶æ ¼å¼åŒ–
  // ...
}
```

### Wordæ–‡æ¡£å¯¼å‡ºå®ç°

ä½¿ç”¨docxåº“ï¼š

```typescript
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';

// å¯¼å‡ºæ¶ˆæ¯ä¸ºWordæ–‡æ¡£
async function exportToWord(messageId: string, fileName?: string) {
  // è·å–æ¶ˆæ¯
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // åˆ›å»ºæ–‡æ¡£
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        new Paragraph({
          text: `${message.role === 'user' ? 'ç”¨æˆ·' : 'AI'} æ¶ˆæ¯`,
          heading: HeadingLevel.HEADING_1,
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: new Date(message.timestamp).toLocaleString(),
              color: '7f8c8d',
              size: 24, // 12pt
            }),
          ],
        }),
        new Paragraph({}), // ç©ºè¡Œ
        ...convertContentToParagraphs(message.content)
      ],
    }],
  });
  
  // ç”Ÿæˆblob
  const blob = await Packer.toBlob(doc);
  
  // ä¸‹è½½æ–‡ä»¶
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName || `message-${messageId}.docx`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// å°†æ¶ˆæ¯å†…å®¹è½¬æ¢ä¸ºWordæ–‡æ¡£æ®µè½
function convertContentToParagraphs(content: string) {
  // æŒ‰è¡Œåˆ†å‰²å†…å®¹
  const lines = content.split('\n');
  
  // è½¬æ¢ä¸ºæ®µè½
  return lines.map(line => {
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„è§£æé€»è¾‘ï¼Œå¦‚ä»£ç å—ã€åˆ—è¡¨ç­‰
    return new Paragraph({
      text: line,
    });
  });
}

// å¯¼å‡ºæ•´ä¸ªå¯¹è¯ä¸ºWord
async function exportConversationToWord(conversationId: string) {
  // é€»è¾‘ç±»ä¼¼ï¼Œä½†éœ€è¦è·å–å®Œæ•´å¯¹è¯å¹¶æ ¼å¼åŒ–
  // ...
}
```

## å¯¼å‡ºæ ·å¼å’Œæ¨¡æ¿

### è‡ªå®šä¹‰å¯¼å‡ºæ¨¡æ¿

```typescript
interface ExportTemplate {
  id: string;           // æ¨¡æ¿å”¯ä¸€æ ‡è¯†
  name: string;         // æ¨¡æ¿åç§°
  format: 'markdown' | 'pdf' | 'word'; // é€‚ç”¨æ ¼å¼
  template: string;     // æ¨¡æ¿å†…å®¹æˆ–HTMLæ¨¡æ¿
  createdAt: number;    // åˆ›å»ºæ—¶é—´
  lastUsed?: number;    // æœ€åä½¿ç”¨æ—¶é—´
  isDefault?: boolean;  // æ˜¯å¦ä¸ºé»˜è®¤æ¨¡æ¿
}

// ç¤ºä¾‹æ¨¡æ¿
const DEFAULT_TEMPLATES: ExportTemplate[] = [
  {
    id: 'default-markdown',
    name: 'æ ‡å‡†Markdown',
    format: 'markdown',
    template: `# {{{role}}} - {{{timestamp}}}

{{{content}}}

---`,
    createdAt: Date.now(),
    isDefault: true
  },
  {
    id: 'default-pdf',
    name: 'æ ‡å‡†PDF',
    format: 'pdf',
    template: `
<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px;">
  <h1 style="color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px;">
    {{{roleName}}}
  </h1>
  <p style="color: #7f8c8d; font-size: 14px;">
    {{{timestamp}}}
  </p>
  <div style="margin-top: 20px; line-height: 1.6; white-space: pre-wrap;">
    {{{formattedContent}}}
  </div>
</div>
    `,
    createdAt: Date.now(),
    isDefault: true
  }
];

// ä½¿ç”¨æ¨¡æ¿å¯¼å‡º
async function exportWithTemplate(messageId: string, templateId: string) {
  // è·å–æ¶ˆæ¯å’Œæ¨¡æ¿
  const [message, template] = await Promise.all([
    getMessageById(messageId),
    getTemplateById(templateId)
  ]);
  
  if (!message || !template) return;
  
  // å‡†å¤‡æ›¿æ¢æ•°æ®
  const replaceData = {
    role: message.role,
    roleName: message.role === 'user' ? 'ç”¨æˆ·æ¶ˆæ¯' : 'AIå›å¤',
    timestamp: new Date(message.timestamp).toLocaleString(),
    content: message.content,
    formattedContent: formatMessageContent(message.content)
  };
  
  // åº”ç”¨æ¨¡æ¿ï¼ˆç®€å•çš„æ¨¡æ¿æ›¿æ¢ï¼‰
  let result = template.template;
  for (const [key, value] of Object.entries(replaceData)) {
    const regex = new RegExp(`{{{${key}}}}`, 'g');
    result = result.replace(regex, value as string);
  }
  
  // æ ¹æ®æ ¼å¼å¯¼å‡º
  switch (template.format) {
    case 'markdown':
      // å¯¼å‡ºMarkdown
      const blob = new Blob([result], { type: 'text/markdown' });
      downloadBlob(blob, `message-${messageId}.md`);
      break;
    case 'pdf':
      // ä½¿ç”¨HTMLå¯¼å‡ºPDF
      const container = document.createElement('div');
      container.innerHTML = result;
      exportHTMLToPDF(container, `message-${messageId}.pdf`);
      break;
    case 'word':
      // å®ç°Wordæ¨¡æ¿å¯¼å‡º...
      break;
  }
  
  // æ›´æ–°æ¨¡æ¿ä½¿ç”¨æ—¶é—´
  updateTemplateUsage(templateId);
}
```

### å¯¼å‡ºåå¥½è®¾ç½®

```typescript
interface ExportSettings {
  defaultTemplates: {
    markdown: string; // æ¨¡æ¿ID
    pdf: string;      // æ¨¡æ¿ID
    word: string;     // æ¨¡æ¿ID
  };
  includeTimestamp: boolean;
  includeSender: boolean;
  defaultFileName: string; // æ”¯æŒå˜é‡å¦‚ {date}, {time}, {messageId}
  pdfOptions: {
    pageSize: 'a4' | 'letter' | 'legal';
    orientation: 'portrait' | 'landscape';
    margin: number; // mm
    headerTemplate?: string;
    footerTemplate?: string;
  };
  wordOptions: {
    format: 'docx' | 'rtf';
    includeTableOfContents: boolean;
  };
}

// é»˜è®¤è®¾ç½®
const DEFAULT_EXPORT_SETTINGS: ExportSettings = {
  defaultTemplates: {
    markdown: 'default-markdown',
    pdf: 'default-pdf',
    word: 'default-word',
  },
  includeTimestamp: true,
  includeSender: true,
  defaultFileName: 'message-{messageId}-{date}',
  pdfOptions: {
    pageSize: 'a4',
    orientation: 'portrait',
    margin: 15
  },
  wordOptions: {
    format: 'docx',
    includeTableOfContents: false
  }
};

// ä¿å­˜è®¾ç½®
function saveExportSettings(settings: ExportSettings) {
  localStorage.setItem('exportSettings', JSON.stringify(settings));
}

// è·å–è®¾ç½®
function getExportSettings(): ExportSettings {
  const saved = localStorage.getItem('exportSettings');
  if (!saved) return DEFAULT_EXPORT_SETTINGS;
  
  try {
    return JSON.parse(saved) as ExportSettings;
  } catch (e) {
    console.error('è§£æå¯¼å‡ºè®¾ç½®å¤±è´¥', e);
    return DEFAULT_EXPORT_SETTINGS;
  }
}
```

## æµè§ˆå™¨å…¼å®¹æ€§è€ƒè™‘

å¯¹äºä¸åŒæµè§ˆå™¨çš„å…¼å®¹æ€§å¤„ç†ï¼š

```typescript
// æ£€æµ‹æµè§ˆå™¨åŠŸèƒ½
function checkBrowserCapabilities() {
  // æ£€æŸ¥å‰ªè´´æ¿API
  const hasClipboardAPI = navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
  
  // æ£€æŸ¥IndexedDB
  const hasIndexedDB = 'indexedDB' in window;
  
  // æ£€æŸ¥Blobå’ŒURL API
  const hasBlobAndURL = 'Blob' in window && 'URL' in window && typeof URL.createObjectURL === 'function';
  
  return {
    clipboard: hasClipboardAPI,
    indexedDB: hasIndexedDB,
    blobAndURL: hasBlobAndURL
  };
}

// æ ¹æ®æµè§ˆå™¨èƒ½åŠ›æä¾›å¤‡é€‰æ–¹æ¡ˆ
function copyTextFallback(text: string) {
  const capabilities = checkBrowserCapabilities();
  
  if (capabilities.clipboard) {
    // ä½¿ç”¨ç°ä»£å‰ªè´´æ¿API
    return navigator.clipboard.writeText(text);
  } else {
    // å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨document.execCommand (å·²åºŸå¼ƒä½†å…¼å®¹æ€§å¥½)
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    
    try {
      const success = document.execCommand('copy');
      if (!success) throw new Error('å¤åˆ¶å¤±è´¥');
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    } finally {
      document.body.removeChild(textarea);
    }
  }
}
